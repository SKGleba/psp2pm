typedef struct {
  void *addr;
  uint32_t length;
} __attribute__((packed)) region_t;

typedef struct {
  uint32_t unused_0[2];
  uint32_t use_lv2_mode_0; // if 1, use lv2 list
  uint32_t use_lv2_mode_1; // if 1, use lv2 list
  uint32_t unused_10[3];
  uint32_t list_count; // must be < 0x1F1
  uint32_t unused_20[4];
  uint32_t total_count; // only used in LV1 mode
  uint32_t unused_34[1];
  union {
    region_t lv1[0x1F1];
    region_t lv2[0x1F1];
  } list;
} __attribute__((packed)) cmd_0x50002_t;

typedef struct heap_hdr {
  void *data;
  uint32_t size;
  uint32_t size_aligned;
  uint32_t padding;
  struct heap_hdr *prev;
  struct heap_hdr *next;
} __attribute__((packed)) heap_hdr_t;

typedef struct SceSblSmCommPair {
    uint32_t unk_0;
    uint32_t unk_4;
} SceSblSmCommPair;

/*
--------------hook sm_load's set_f00d_state(5) to jump to 0x807c50 whenever a sm gets loaded
	0x00800A06 =	movu	r0,0x807c50
	0x00800A0A =	jsr	r0
--------------code @0x807c50
--------set jig_verified to 1
	0x807c50 =		mov		r2,0x1
	0x807c52 =		movu	r3,0x80ef40
	0x807c56 =		sb		r2,(r3)
--------set f00d_state to 5
	0x807c58 =		mov		r1,0x5
	0x807c5A =		sw		r1,-0x7fe8(gp)
--------return to caller
	0x807c5E =		ret
--------------resume
--------take care of cache
	syncm
--------jump back to 0xd0002
	movu	r3,0x80be90
	jmp		r3
*/
unsigned char patch_pm_jig[] = {
  0x06, 0xd3, 0x0a, 0x80, 0x01, 0xc2, 0x50, 0xd0, 0x39, 0x02, 0x01, 0xc2,
  0x7c, 0x80, 0x39, 0xc2, 0x02, 0x00, 0x01, 0xc2, 0x0f, 0x10, 0x0a, 0xd3,
  0x0a, 0x80, 0x39, 0x02, 0x01, 0xc2, 0x01, 0x52, 0x50, 0xd3, 0x7c, 0x80,
  0x39, 0x02, 0x52, 0xd3, 0x7c, 0x80, 0x01, 0xc2, 0x40, 0xd3, 0x39, 0x02,
  0x01, 0xc2, 0xef, 0x80, 0x39, 0xc2, 0x02, 0x00, 0x01, 0xc2, 0x38, 0x02,
  0x56, 0xd3, 0x7c, 0x80, 0x39, 0x02, 0x01, 0xc2, 0x05, 0x51, 0x58, 0xd3,
  0x7c, 0x80, 0x39, 0x02, 0x5a, 0xd3, 0x7c, 0x80, 0x01, 0xc2, 0xea, 0xc1,
  0x39, 0x02, 0x01, 0xc2, 0x18, 0x80, 0x39, 0xc2, 0x02, 0x00, 0x01, 0xc2,
  0x02, 0x70, 0x5e, 0xd3, 0x7c, 0x80, 0x39, 0x02, 
  0x11, 0x70, 
  0x90, 0xd3, 0xbe, 0x80, 
  0x3e, 0x10
};

/*
--------------hook sm_load's set_f00d_state(5) to jump to 0x807c50 whenever a sm gets loaded
	0x00800A06 =	movu	r0,0x807c50
	0x00800A0A =	jsr	r0
--------------code @0x807c50
--------set jig_verified to 1
	0x807c50 =		mov		r2,0x1
	0x807c52 =		movu	r3,0x80ef40
	0x807c56 =		sb		r2,(r3)
--------set |1 to |3 for FF
	0x807c58 =		mov		r2,0x3
	0x807c5A =		movu	r3,0x80b5de
	0x807c5E =		sb		r2,(r3)
--------set f00d_state to 5
	0x807c60 =		mov		r1,0x5
	0x807c62 =		sw		r1,-0x7fe8(gp)
--------return to caller
	0x807c66 =		ret
--------------resume
--------take care of cache
	syncm
--------jump back to 0xd0002
	movu	r3,0x80be90
	jmp		r3
*/
unsigned char patch_pm_ff_and_jig[] = {
  0x06, 0xd3, 0x0a, 0x80, 0x01, 0xc2, 0x50, 0xd0, 0x39, 0x02, 0x01, 0xc2,
  0x7c, 0x80, 0x39, 0xc2, 0x02, 0x00, 0x01, 0xc2, 0x0f, 0x10, 0x0a, 0xd3,
  0x0a, 0x80, 0x39, 0x02, 0x01, 0xc2, 0x01, 0x52, 0x50, 0xd3, 0x7c, 0x80,
  0x39, 0x02, 0x52, 0xd3, 0x7c, 0x80, 0x01, 0xc2, 0x40, 0xd3, 0x39, 0x02,
  0x01, 0xc2, 0xef, 0x80, 0x39, 0xc2, 0x02, 0x00, 0x01, 0xc3, 0x38, 0x02,
  0x56, 0xd2, 0x7c, 0x80, 0x29, 0x03, 0x01, 0xc1, 0x03, 0x52, 0x58, 0xd2,
  0x7c, 0x80, 0x29, 0x01, 0x5a, 0xd2, 0x7c, 0x80, 0x01, 0xc1, 0xde, 0xd3,
  0x29, 0x01, 0x01, 0xc1, 0xb5, 0x80, 0x29, 0xc1, 0x02, 0x00, 0x5e, 0xd2,
  0x7c, 0x80, 0x29, 0x03, 0x01, 0xc2, 0x05, 0x51, 0x60, 0xd3, 0x7c, 0x80,
  0x39, 0x02, 0x62, 0xd3, 0x7c, 0x80, 0x01, 0xc2, 0xea, 0xc1, 0x39, 0x02,
  0x01, 0xc2, 0x18, 0x80, 0x39, 0xc2, 0x02, 0x00, 0x01, 0xc2, 0x02, 0x70,
  0x66, 0xd3, 0x7c, 0x80, 0x39, 0x02, 
  0x11, 0x70, 
  0x90, 0xd3, 0xbe, 0x80,
  0x3e, 0x10
};

#define LOG(...) \
	do { \
		char buffer[256]; \
		snprintf(buffer, sizeof(buffer), ##__VA_ARGS__); \
		logg(buffer, strlen(buffer), LOG_LOC, 2); \
} while (0)
	
#define LOG_START(...) \
	do { \
		char buffer[256]; \
		snprintf(buffer, sizeof(buffer), ##__VA_ARGS__); \
		logg(buffer, strlen(buffer), LOG_LOC, 1); \
} while (0)
	
#define NZERO_RANGE(off, end) \
	do { \
		int curr = 0; \
		while (off + curr < end + 4) { \
			nzero32((off + curr)); \
			curr = curr + 4; \
		} \
} while (0)

static int logg(void *buffer, int length, const char* logloc, int create)
{
	int fd;
	if (create == 0) {
		fd = ksceIoOpen(logloc, SCE_O_WRONLY | SCE_O_APPEND, 6);
	} else if (create == 1) {
		fd = ksceIoOpen(logloc, SCE_O_WRONLY | SCE_O_TRUNC | SCE_O_CREAT, 6);
	} else if (create == 2) {
		fd = ksceIoOpen(logloc, SCE_O_WRONLY | SCE_O_APPEND | SCE_O_CREAT, 6);
	}
	if (fd < 0)
		return 0;

	ksceIoWrite(fd, buffer, length);
	ksceIoClose(fd);
	return 1;
}